# Buffer Overflow
## 1. Introduction to x86 Arch
### 1.1 Program Memory
![image](https://user-images.githubusercontent.com/43812413/132995755-5f51a287-1012-4dcf-b16d-d7b328e83b2b.png)
- **Stack**: When a thread is running, it execute code from within the Progream Image or from various Dynamic Link Libraries (DLLs). The thread requires a short-term data areas for functions, local variables, and programm control information, which is known as the stack. Each thread has its own stack. Stack memory is viewed by the CPU as a LIFO structure. This means that while accessing the stack, items put on the top of the stack are removed first. The x86 arch implements PUSH and POP assembly instructions in order to add or remove data to the stack respectively
- **Function Return Mechanics**: When code within a thread calls a function, it must know whuch address to return to once the function completes. This "return address" is stored on the stack. This collection of data is associated with one function call and is stored in a section of the stack memory known as a stack frame. When function ends, the return address is taken from the stack and used to restore the execution flow back to the main program of the calling function.
- **CPU Registers**: To perfrorm efficient code execution, the CPU maintains and uses a series of nine 32-bit registers. Registers are small, extremely high-speed CPU storage locations where data can be efficienly read or manipulated. 
- **ESP - The Stack Pointer**: Since the stack is dynamic and changes constantly during program execution, ESP, keeps track of the most recently referenced location on the stack (top of the stack) by storing a pointer to it
- **EBP - The Base Pointer**: Since the stack is in constant flux, it can become difficult for a function to locate its own stack frame, which stores the required arguments, local variables, and the return address. EBP solves this by storing a pointer to the top of the stack when a function is called. By accessing EBP, a function can easily reference information from its own stack frame (via offsets) while executing.
- **EIP - The Instructor Pointer**: EIP, the instructor pointer, is one of the most important registers for Buffer Overlows, as it always points to the next code instruction to be executed. Since EIP essentially directs the flow of a program, it is an attacker's primary target when exploiting any memory corruption vuln.

## 2. Buffer Overlow
### 2.1 Spiking
The test will be done in the vulnerable executable **vulnserver**.
First of all we will open our **Immunity Debugger** as an Administrator, then we will select **File -> Attach**. Once we are in **Attach** we select **vulnserver**:
![image](https://user-images.githubusercontent.com/43812413/132997437-1689629e-0b48-4465-b567-f2936108d58b.png)

We will press **start** ![image](https://user-images.githubusercontent.com/43812413/132997451-0cc4a42f-a8a2-4f7d-9a30-b46940c2826c.png)
We should see *Running* on the bottom.

Then we will go to our **Kali**, and will try to connect with **netcat** to **vulnserver**:

![image](https://user-images.githubusercontent.com/43812413/132997506-cbb43b46-f841-4e27-ae16-74357492a7b7.png)

If we type **HELP** a list of available commands is displaied:

![image](https://user-images.githubusercontent.com/43812413/132997545-a0cbeff8-a2da-4e97-89a2-203766dd3deb.png)

We will focus in **TRUN** command, which is the one vulnerable to BOFs.
The aim of **Spiking** is grab one of that commands, for instance **STATS** and see if there is a possibility that with that command there is a BOF. 
In **Spiking** we will use a tool called **generic_send_tcp**:

![image](https://user-images.githubusercontent.com/43812413/132997692-48c05e2e-8155-4107-affc-725060ac9872.png)

The **spike_script** is as follows:
  1. We create a file called **spike.spk**
  2. We write the next code:
  
  ![image](https://user-images.githubusercontent.com/43812413/132997862-54e3f8e6-2901-4f0a-8166-8eddea427c5a.png)
  
Once we have our **spike_script** we type the following:
```bash
generic_send_tcp 192.168.1.128 9999 spike.spk 0 0
```
When RETURN is pressed, a lot of character will be sent. If the command is vulnerable, in **Immunity Debugger** the programm will stop.
If we abuse the **TRUN** command the next has to happen in **Immunity Debugger**:

![image](https://user-images.githubusercontent.com/43812413/132997921-230378fa-d21a-4c02-b905-ef61d7eee7ab.png)

**Vulnserver** has crashed. The **ESP**, the **EBP** and the **EIP** are filled wit **A's**, this means that we had a BOF.





